#include "FusionEKF.h"#include "tools.h"#include "Eigen/Dense"#include <iostream>using namespace std;using Eigen::MatrixXd;using Eigen::VectorXd;using std::vector;/* * Constructor. */FusionEKF::FusionEKF() {    is_initialized_ = false;    previous_timestamp_ = 0;    // initializing matrices    R_laser_ = MatrixXd(2, 2);    R_radar_ = MatrixXd(3, 3);    H_laser_ = MatrixXd(2, 4);    Hj_ = MatrixXd(3, 4);    //measurement covariance matrix - laser    R_laser_ << 0.0225, 0,                0,      0.0225;    //measurement covariance matrix - radar    R_radar_ << 0.09,   0,      0,                0,      0.0009, 0,                0,      0,      0.09;    H_laser_ << 1, 0, 0, 0,                0, 1, 0, 0;    //create a 4D state vector, we don't know yet the values of the x state    VectorXd x_ = VectorXd(4);    x_ <<  1,1,1,1;    MatrixXd P_ = MatrixXd(4,4);    P_ <<   1,  0,  0,      0,            0,  1,  0,      0,            0,  0,  1000,   0,            0,  0,  0,      1000;    MatrixXd F_ = MatrixXd(4,4);    MatrixXd Q_ = MatrixXd(4,4);    ekf_.Init(x_, P_, F_, H_laser_, R_laser_, Q_);}/*** Destructor.*/FusionEKF::~FusionEKF() {}void FusionEKF::ProcessMeasurement(const MeasurementPackage &measurement_pack) {  /*****************************************************************************   *  Initialization   ****************************************************************************/  if (!is_initialized_) {    // first measurement    if (measurement_pack.sensor_type_ == MeasurementPackage::RADAR) {      /**      Convert radar from polar to cartesian coordinates and initialize state.      */        ekf_.x_(0) = measurement_pack.raw_measurements_(0)*cos(measurement_pack.raw_measurements_(1));        ekf_.x_(1) = measurement_pack.raw_measurements_(0)*sin(measurement_pack.raw_measurements_(1));        // Check for initial zero values. Increase the "uncertainty", i.e. the covariance if zero values are found.        if(ekf_.x_(0) < 0.0001) {            ekf_.x_(0) = 1.0;            ekf_.P_(1,1) = 1000;        }        if(ekf_.x_(1) < 0.0001) {            ekf_.x_(1) = 1.0;            ekf_.P_(1,1) = 1000;        }    }    else if (measurement_pack.sensor_type_ == MeasurementPackage::LASER) {      /**      Initialize state.      */      ekf_.x_(0) = measurement_pack.raw_measurements_(0);      ekf_.x_(1) = measurement_pack.raw_measurements_(1);    }    // done initializing, no need to predict or update    previous_timestamp_ = measurement_pack.timestamp_;    is_initialized_ = true;    return;  }  /*****************************************************************************   *  Prediction   ****************************************************************************/    float dt = (measurement_pack.timestamp_ - previous_timestamp_) / 1000000.0;    previous_timestamp_ = measurement_pack.timestamp_;    ekf_.F_ <<  1,  0,  dt, 0,                0,  1,  0,  dt,                0,  0,  1,  0,                0,  0,  0,  1;    float dt_2 = pow(dt, 2.0);    float dt_3 = pow(dt, 3.0);    float dt_4 = pow(dt, 4.0);    float noise_ax = 9.0;    float noise_ay = 9.0;    //set the process covariance matrix Q    ekf_.Q_ <<   dt_4/4*noise_ax, 0, dt_3/2*noise_ax, 0,                0, dt_4/4*noise_ay, 0, dt_3/2*noise_ay,                dt_3/2*noise_ax, 0, dt_2*noise_ax, 0,                0, dt_3/2*noise_ay, 0, dt_2*noise_ay;    ekf_.Predict();  /*****************************************************************************   *  Update   ****************************************************************************/  if (measurement_pack.sensor_type_ == MeasurementPackage::RADAR) {    // Radar updates    ekf_.H_ = tools.CalculateJacobian(ekf_.x_);    ekf_.R_ = R_radar_;    ekf_.UpdateEKF(measurement_pack.raw_measurements_);  } else {    // Laser updates    ekf_.H_ = H_laser_;    ekf_.R_ = R_laser_;    ekf_.Update(measurement_pack.raw_measurements_);  }}